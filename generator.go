package main

import (
	"fmt"
	"io"
	"os"
)

func generateConfig(state *state, w io.Writer) error {
	PostUp := ""
	PostDown := ""

	wd, err := os.Getwd()
	if err != nil {
		panic("can't os.Getwd " + err.Error())
	}
	comment := "# This file is generated by wg-dir-conf from directory " + wd
	comment += "\n# It it likely to be overwritten.\n"

	_, err = fmt.Fprintf(w, "%s\n[Interface]\n", comment)
	if err != nil {
		return fmt.Errorf("generateConfig error %w", err)
	}
	if state.server.Address4 != "" {
		_, _ = fmt.Fprintln(w, "Address =", state.server.Address4)
		PostUp = PostUp + state.server.PostUp4
		PostDown = PostDown + state.server.PostDown4
	}
	if state.server.Address6 != "" {
		_, _ = fmt.Fprintln(w, "Address =", state.server.Address6)
		PostUp = PostUp + state.server.PostUp6
		PostDown = PostDown + state.server.PostDown6
	}
	_, _ = fmt.Fprintln(w, "PostUp =", PostUp)
	_, _ = fmt.Fprintln(w, "PostDown =", PostDown)
	_, _ = fmt.Fprintln(w, "ListenPort =", state.server.ListenPort)
	_, _ = fmt.Fprintln(w, "PrivateKey =", state.server.PrivateKey)

	for _, client := range state.clients {
		err = generateClientConfig(state.server, client, w)
		if err != nil {
			return fmt.Errorf("generateConfig error %w", err)
		}
	}

	return nil
}

func generateClientConfig(srv *server, client *client, w io.Writer) error {
	_, err := fmt.Fprintf(w, "\n# peer %s\n", client.name)
	if err != nil {
		return fmt.Errorf("generateConfig error %w", err)
	}
	_, _ = fmt.Fprintln(w, "[Peer]")
	_, _ = fmt.Fprintln(w, "PublicKey =", client.PublicKey)
	allowedIps, err := client.allowedIps(srv)
	if err != nil {
		return fmt.Errorf("generateClientConfig error %w", err)
	}
	_, _ = fmt.Fprintln(w, "AllowedIPs =", allowedIps)

	return nil
}
